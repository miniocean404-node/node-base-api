# flag 文件系统标志
以下标志在 flag 选项接受字符串的任何地方可用。
1. 'a': 打开文件进行追加。 如果文件不存在，则创建该文件。
2. 'ax': 类似于 'a' 但如果路径存在则失败。
3. 'a+': 打开文件进行读取和追加。 如果文件不存在，则创建该文件。
4. 'ax+': 类似于 'a+' 但如果路径存在则失败。
5. 'as': 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。
6. 'as+': 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。
7. 'r': 打开文件进行读取。 如果文件不存在，则会发生异常。
8. 'r+': 打开文件进行读写。 如果文件不存在，则会发生异常。
9. 'rs+': 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。
   这主要用于在 NFS 挂载上打开文件，因为它允许跳过可能过时的本地缓存。 它对 I/O 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。
   这不会将 fs.open() 或 fsPromises.open() 变成同步阻塞调用。 如果需要同步操作，应该使用类似 fs.openSync() 的东西。
10. 'w': 打开文件进行写入。 创建（如果它不存在）或截断（如果它存在）该文件。
11. 'wx': 类似于 'w' 但如果路径存在则失败。
12. 'w+': 打开文件进行读写。 创建（如果它不存在）或截断（如果它存在）该文件。
13. 'wx+': 类似于 'w+' 但如果路径存在则失败。

flag 也可以是 open(2) 记录的数字；常用的常量可从 fs.constants 获得。 在 Windows 上，标志会在适用的情况下转换为等效的标志，例如 O_WRONLY 至 FILE_GENERIC_WRITE，或 O_EXCL|O_CREAT 至 CREATE_NEW，为 CreateFileW 所接受。
如果路径已经存在，则独占标志 'x'（ open(2) 中的 O_EXCL 标志）会导致操作返回错误。 在 POSIX 上，如果路径是符号链接，即使链接指向不存在的路径，使用 O_EXCL 也会返回错误。

在 Linux 上，以追加模式打开文件时，位置写入不起作用。 内核会忽略位置参数，并始终将数据追加到文件末尾。
某些标志的行为是特定于平台的。 因此，在 macOS 和 Linux 上使用 'a+' 标志打开目录，如下例所示，将返回错误。 而在 Windows 和 FreeBSD 上，将返回文件描述符或 FileHandle。

在 Windows 上，使用 'w' 标志（通过 fs.open() 或 fs.writeFile() 或 fsPromises.open()）打开现有隐藏文件将失败并抛出 EPERM。 可以使用 'r+' 标志打开现有的隐藏文件进行写入。
调用 fs.ftruncate() 或 filehandle.truncate() 可用于重置文件内容。

# mode

## 文件访问的常量
F_OK	指示文件对调用进程可见的标志。 这对于确定文件是否存在很有用，但没有说明 rwx 权限。 未指定模式时的默认值。
R_OK	指示文件可以被调用进程读取的标志。
W_OK	指示文件可以被调用进程写入的标志。
X_OK	指示文件可以被调用进程执行的标志。 这在 Windows 上不起作用（行为类似于 fs.constants.F_OK）。

## 文件的模式（读写权限）
fs.constants.S_IRUSR	0o400	所有者可读取
fs.constants.S_IWUSR	0o200	所有者可写入
fs.constants.S_IXUSR	0o100	所有者可执行/搜索
fs.constants.S_IRGRP	0o40	群组可读取
fs.constants.S_IWGRP	0o20	群组可写入
fs.constants.S_IXGRP	0o10	群组可执行/搜索
fs.constants.S_IROTH	0o4	其他人可读取
fs.constants.S_IWOTH	0o2	其他人可写入
fs.constants.S_IXOTH	0o1	其他人可执行/搜索
构建 mode 的一种更简单的方法是使用三个八进制数字的序列（例如 765）
最左边的数字（示例中的 7）指定文件所有者的权限。 中间的数字（示例中的 6）指定群组的权限。 最右边的数字（示例中的 5）指定其他人的权限。
7	可读、可写和可执行
6	可读和可写
5	可读和可执行
4	只读
3	可写和可执行
2	只写
1	只可执行
0	无权限
注意事项：在 Windows 上只能更改写入权限，并没有实现群组、所有者或其他人权限之间的区别。

# 文件打开的常量
以下常量旨在与 fs.open() 一起使用。

O_RDONLY	指示打开文件以进行只读访问的标志。
O_WRONLY	指示打开文件以进行只写访问的标志。
O_RDWR	指示打开文件以进行读写访问的标志。
O_CREAT	如果文件不存在则指示创建文件的标志。
O_EXCL	如果设置了 O_CREAT 标志并且文件已经存在，则指示打开文件应该失败的标志。
O_NOCTTY	标志表示如果路径标识一个终端设备，打开路径不应导致该终端成为进程的控制终端（如果进程还没有一个）。
O_TRUNC	标志表示如果文件存在并且是一个普通文件，并且该文件被成功打开以进行写访问，则其长度应被截断为零。
O_APPEND	指示数据将追加到文件末尾的标志。
O_DIRECTORY	如果路径不是目录，则表示打开应该失败的标志。
O_NOATIME	指示对文件系统的读取访问的标志将不再导致与文件关联的 atime 信息的更新。 此标志仅在 Linux 操作系统上可用。
O_NOFOLLOW	如果路径是符号链接，则表示打开应该失败的标志。
O_SYNC	指示文件为同步 I/O 打开的标志，写操作等待文件完整性。
O_DSYNC	指示文件为同步 I/O 打开的标志，写操作等待数据完整性。
O_SYMLINK	指示打开符号链接本身而不是它指向的资源的标志。
O_DIRECT	设置后，将尝试最小化文件 I/O 的缓存影响。
O_NONBLOCK	指示在可能的情况下以非阻塞模式打开文件的标志。
UV_FS_O_FILEMAP	设置后，将使用内存文件映射来访问文件。 此标志仅在 Windows 操作系统上可用。 在其他操作系统上，此标志被忽略。

# 文件类型的常量
以下常量旨在与 fs.Stats 对象的 mode 属性一起使用，以确定文件的类型。

S_IFMT	用于提取文件类型代码的位掩码。
S_IFREG	常规文件的文件类型常量。
S_IFDIR	目录的文件类型常量。
S_IFCHR	面向字符的设备文件的文件类型常量。
S_IFBLK	面向块的设备文件的文件类型常量。
S_IFIFO	FIFO/管道的文件类型常量。
S_IFLNK	符号链接的文件类型常量。
S_IFSOCK	套接字的文件类型常量。

# 文件复制的常量
以下常量旨在与 fs.copyFile() 一起使用。

COPYFILE_EXCL	如果存在，如果目标路径已经存在，复制操作将失败并显示错误。
COPYFILE_FICLONE	如果存在，复制操作将尝试创建写时复制引用链接。 如果底层平台不支持写时复制，则使用回退复制机制。
COPYFILE_FICLONE_FORCE	如果存在，复制操作将尝试创建写时复制引用链接。 如果底层平台不支持写时复制，则操作将失败并显示错误。
